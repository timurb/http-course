= HTTP и все все все
:toc:

Это краткий текстовый курс, который знакомит с устройством, назначением и особенностями протокола HTTP.

Вы спросите, зачем он нужен? Ведь ничего сложного в HTTP/200 и HTTP/404 нет.

Сложного действительно нет, но когда начинает взаимодействовать несколько разных компонентов с редиректами и проксированием новички часто путаются с тем, что происходит в системе.

Этот курс для них. В начале мы познакомимся с тем, из чего вообще состоит протокол HTTP, затем поговорим о том, какими инструментами с ним работать, после этого рассмотрим типовые сценарии развертывания приложений, с которыми вы рано или поздно встретитесь при работе с HTTP, и под конец поговорим о том, как обычно происходит аутентификация и авторизация при доступе к API. В конце возможно затронем темы о том, как работает с HTTP броузер, но это точно не в приоритете.

== HTTP и его составляющие

Современные приложения часто строятся с расчетом, что они будут так или иначе взаимодействовать по сети с другими приложениями -- либо к ним будут обращаться удаленные клиенты, либо они будут обращаться к другим клиентам, а нередко и то и другое.

Наверное, HTTP самый распространенный протокол для такого взаимодействия, при этом он с одной стороны достаточно простой, а с другой стороны в современных системах в нем бывает довольно много нюансов.

(см также https://ru.wikipedia.org/wiki/HTTP)


== URI

Любые адреса обычно записываются в формате URI -- это универсальный формат записи ссылок. Мы рассмотрим его применительно к HTTP и е будем рассматривать другие случаи.

Итак, адрес любого объекта, который можно получить по HTTP выглядит так:

``http://www.example.com:80/path``

Это полная форма представления, мы рассмотрим все ее составляющие, а также как происходит обмен данными между сервером и клиентом.

Составляющие здесь такие:

 - `http://` -- __схема__ URI. Для HTTP она всегда `http://`, либо `https://` для шифрованного соединения. Она указывает броузеру как ему обратиться к URI -- в данном случае это протокол HTTP или HTTPS. Существуют и другие варианты (`ftp://`, `file://`) -- их мы рассматривать не будем
 - `www.example.com` -- __адрес сервера__ к которому подключается клиент. Может быть любым, который поддерживает сетевой стек клиента -- IPv4 (`192.168.1.234`), DNS (`www.example.com`) или IPv6(`fdf0:af47:7b2f:0141`).
 - `:80` -- __порт__ к которому подключается клиент. Если он не указан, подразумевается порт 80 для протокола HTTP и порт 443 для протокола HTTPS 
 - `/path` -- __путь__ на сервере, который пытается запросить клиент. Всегда должен начинаться с `/`. Если не указан по умолчанию будет использован путь `/`.

Что происходит когда клиент пытается запросить данные по этому адресу?

[mermaid]
....
sequenceDiagram
actor user as User
participant http as HTTP Server at www.example.com
participant google as HTTP Server at www.google.com

Note over user: Открыть http://www.example.com/index.html
user ->> http: GET /index.html
http -->> user: возвращает содержимое файла /index.html
Note over user: Видит содержимое файла/рендерится страница в броузере
....

1. Клиент устанавливает сетевое соединение по указанному адресу+порту. В случае HTTPS происходит SSL-handshake.
2. Клиент отправляет команду HTTP на сервер, забирает ответ сервера и, например, выводит его пользователю на экран, или рендерит в виде web-страницы

В дальнейшем мы не будем больше говорить про пару адрес+порт, т.к. с этим меньше всего нюансов. Схему (http, https) тоже затронем только вскользь. А все остальные составляющие рассмотрим подробнее.

=== HTTP Path

После того как клиент подключился к серверу на уровне L4 (TCP/IP) он передает по установленному соединению команды HTTP.

Пример:

`GET /index.html`

Как мы уже выяснили, `/index.html` это та часть URI, которая идет сразу после хоста с портом.  

=== Response

В ответ HTTP-сервер __всегда__ шлет код возврата с кратким описанием, и иногда еще какое-то дополнительное содержимое.

[mermaid]
....
sequenceDiagram
actor user as User
participant http as HTTP Server

user ->> http: GET /index.html
http -->> user: HTTP/1.0 200 OK
http ->> user: ..Headers..
http ->> user: ..Данные..
....

Вот пример реального запроса:

    $ curl -v www.google.com > /dev/null
    Trying 173.194.73.99...
    * Connected to www.google.com (173.194.73.99) port 80 (#0)
    > GET / HTTP/1.1
    > Host: www.google.com
    > User-Agent: curl/7.54.0
    > Accept: */*
    >
    < HTTP/1.1 200 OK
    < Date: Thu, 22 Jun 2023 21:37:50 GMT
    < Expires: -1
    < Cache-Control: private, max-age=0
    < Content-Type: text/html; charset=ISO-8859-1
    < .............................

Здесь отправляется команда `GET /` (здесь `HTTP/1.1` указывает на версию протокола и ее можно опустить) с заголовками и возвращается код ответа с описанием `HTTP/1.1 200 OK` и дальше заголовки и содержимое ответа.

В данном случае код возврата -- `200`, его строка описания -- `OK`.
Полный список кодов можно посмотреть например https://ru.wikipedia.org/wiki/Список_кодов_состояния_HTTP[на википедии], или поискать разнообразные https://blog.alphageek.com.au/2020/02/16/http-status-codes[шуточные варианты]. 

На практике их всех учить не обязательно и достаточно запомнить несложную эвристику в каких случаях каким кодом отвечает сервер:

 - 1xx: "Подождите еще" (ни разу не видел коды из этой серии)
 - 2xx: "Вот твои данные"
 - 3xx: "Перейди по этому адресу"
 - 4xx: "Ты облажался" (что-то не то с запросом который ко мне пришел)
 - 5xx: "Я облажался" (у меня какие-то внутренние проблемы)

=== Verb

Итак, с путем запроса и ответом сервера разобрались. Что еще важного содержится в запросе клиента?

Команда клиента серверу.

Команды бывают следующие:

 - `GET` -- получить данные с сервера
 - `POST` -- отправить данные на сервер

=== Params
=== Body
=== Headers

== Инструменты
=== curl, httpie, httpie-go
=== Postman
=== netcat
=== openssl s_client

== Развертывание приложений
=== nginx / static pages
==== redirect
==== Host
=== application
=== nginx + application
==== rewrite
==== кэширование запросов
==== 301 и 302
=== redirect vs rewrite

== Взаимодействие с API и IAM
=== Authentication
=== Authorization
=== SSO
=== Application tokens
=== JWT
=== (optional) Sessions + Cookies

== (optional) Работа с броузером и JS
=== CORS, OPTIONS, HEAD
=== WebSockets